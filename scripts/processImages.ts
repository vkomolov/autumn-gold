import { createWriteStream } from 'fs';
import { promises as fs } from 'fs';
import { pipeline } from 'stream/promises';
import * as path from 'path';
import { get as httpsGet } from 'https';
import * as cliProgress from 'cli-progress';
import { fetchData, toPathUrl } from "./utils";
import type { ICmsImageItem } from "../src/types";

/* =========================================================
 *  Universal image-map generator for Next.js
 * ----------------------------------------------------------
 *  1. Fetches image lists from CMS or local mocks
 *  2. Downloads remote files into src/assets/imagesStatic
 *  3. Deduplicates by basename
 *  4. Writes static imports for next/image optimisation
 * ----------------------------------------------------------
 * *! include to scripts (!RENAME this file to processImagesOldVer.ts:):
 * "generate:images": "tsx scripts/processImagesOldVer.ts",
 *
 *! include to scripts dev:
 * "dev": "npm-run-all -s tidy generate:images && concurrently \"next dev --turbopack\" \"npx next-video sync --watch\"",
 *
 *! include to scripts build:
 * "build": "npm-run-all -s tidy generate:images npx next-video sync next build"
 * ========================================================= */

/* =========================================================
*  Configuration
* ! read docs/image-strategy.md
* ========================================================= */
const IMAGES_DIR = toPathUrl('src/assets/imagesStatic');
const OUT_FILE   = toPathUrl('src/lib/generated/imageMap.ts');

//console.log('IMAGES_DIR =', IMAGES_DIR);  //D:\GIT\autumn-gold\src\assets\imagesStatic
//console.log('OUT_FILE   =', OUT_FILE); //D:\GIT\autumn-gold\src\lib\generated\imageMap.ts
//process.exit(0);

const SOURCES: string[] = [
	//"https://cms.example.com/api/images",
	"scripts/lib/mockImages.ts",  // export default mock images: ICmsImageItem[] from scripts
];

const AUTO_PREFIX = 'cms_'; // prefix for downloaded files from CMS API
//const SUPPORTED_EXT = ['webp','jpg','jpeg','png','svg'];  //option for a pattern list: string[]
//const extGlob = SUPPORTED_EXT.join(',');  //option for a joined pattern list: string

/* ------------------------------------------------------------------ */
/*  Download helper                                                   */
/* ------------------------------------------------------------------ */
async function download(url: string, file: string): Promise<void> {
	return new Promise<void>((resolve, reject) => {
		httpsGet(url, async (res) => {
			if (res.statusCode !== 200) return reject(new Error(`Download ${res.statusCode}`));
			await pipeline(res, createWriteStream(file));
			resolve();
		}).on('error', reject);
	});
}

/* ------------------------------------------------------------------ */
/*  Main                                                              */
/* ------------------------------------------------------------------ */
(async () => {

	console.log('üì•  Fetching image lists‚Ä¶');
	const raw = await Promise.all(SOURCES.map(source => fetchData<ICmsImageItem[]>(source)));
	const items: ICmsImageItem[] = raw.flat();

	/* ---------- dedupe by basename ---------- */
	const seen = new Set<string>();
	const unique = items.filter(it => {
		const key = path.basename(it.url);

		return !seen.has(key) && Boolean(seen.add(key));
	});

	/* ---------- progress bar ---------- */
	const bar = new cliProgress.SingleBar({}, cliProgress.Presets.shades_classic);
	bar.start(unique.length, 0);

	const descriptors: {
		varName: string;
		baseName: string;
		importPath: string;
	}[] = [];

	for (const [idx, it] of unique.entries()) {
		bar.update(idx + 1);

		const isRemote = it.url.startsWith('http');
		const baseName = path.basename(it.url);
		const fileName = isRemote ? `${AUTO_PREFIX}${baseName}` : baseName;
		const localPath = path.join(IMAGES_DIR, fileName);

		/* ensure folder exists */
		await fs.mkdir(IMAGES_DIR, { recursive: true });

		/* download if missing */
		if (isRemote && !(await fs.stat(localPath).catch(() => false))) {
			await download(it.url, localPath);
		}

		/* build descriptor */
		const varName = `img${idx}`;
		const importPath = `@/assets/imagesStatic/${fileName}`;

		descriptors.push({ varName, baseName, importPath });
	}

	bar.stop();

	/* ---------- generate TS module ---------- */
	const imports = descriptors.map(d => `import ${d.varName} from "${d.importPath}";`);
	const mapEntries = descriptors.map(d => `  "${d.baseName}": ${d.varName},`);

	const code = [
		'/**',
		' * ‚ö†Ô∏è AUTO-GENERATED FILE ‚Äì DO NOT EDIT MANUALLY',
		' * Generated by:  npm run generate:images',
		' */',
		'',
		...imports,
		'',
		'export const imageMap = {',
		...mapEntries,
		'} as const;',
		'',
		'export type ImageMapKey = keyof typeof imageMap;',
		'',
	].join('\n');

	await fs.mkdir(path.dirname(OUT_FILE), { recursive: true });
	await fs.writeFile(OUT_FILE, code, 'utf8');

	console.log('‚úÖ  imageMap.ts created / updated');
})().catch(err => {
	console.error('‚ùå  Error:', err);
	process.exitCode = 1;
});
