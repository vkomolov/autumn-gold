import {createWriteStream} from "fs";
import {promises as fs} from "fs";
import {pipeline} from "stream/promises";
import * as path from "path";
import {get as httpsGet} from "https";
import cliProgress from "cli-progress";

import { fetchData, toPathUrl } from "./utils";
import type { ICmsVideoItem } from "../src/types";

/* =========================================================
 * Auto-generates src/lib/generated/videosMap.ts
 * 1. Fetches video lists from CMS or local mocks
 * 2. Downloads remote files into videos/ (alias @v/*)
 * 3. Deduplicates by basename
 * 4. Writes static imports for next-video optimisation
 * ----------------------------------------------------------
 *! include to scripts:
 * "generate:videos": "tsx scripts/processVideos.ts",
 *
 *! include to dev:
 * "npm-run-all -s tidy generate:images generate:videos && concurrently \"next dev --turbopack\" \"npx next-video sync --watch\"",
 *
 *! include to build:
 * "npm-run-all -s tidy generate:images generate:videos npx next-video sync next build"
 *
 * TODO: read docs/video-strategy.md
 *
 * ========================================================= */

/* ---------- config ---------- */
const VIDEOS_DIR = toPathUrl("videos");
const OUT_FILE = toPathUrl("src/lib/generated/videosMap.ts");

const SOURCES: string[] = [
	//"https://cms.example.com/api/videos",
	"scripts/lib/mockVideos.ts",  // export default mock videos: ICmsVideoItem[] from scripts
];

const AUTO_PREFIX = "cms_"; // prefix for downloaded files from CMS API
/* ---------------------------- */

//await fs.mkdir(VIDEOS_DIR, {recursive: true});


/* ------------------------------------------------------------------ */
/*  Download helper                                                   */
/* ------------------------------------------------------------------ */
async function download(url: string, file: string): Promise<void> {
	return new Promise<void>((resolve, reject) => {
		httpsGet(url, async (res) => {
			if (res.statusCode !== 200) {
				return reject(new Error(`Download failed: ${res.statusCode}`));
			}
			await pipeline(res, createWriteStream(file));
			resolve();  //when pipeline is complete, we close the promise with empty resolve() and go next below...
		}).on('error', reject);
	});
}

/* ------------------------------------------------------------------ */
/*  Main                                                              */
/* ------------------------------------------------------------------ */
(async () => {
	console.log('üì•  Fetching video lists‚Ä¶');

	/* ensure folder exists */
	await fs.mkdir(VIDEOS_DIR, { recursive: true });

	const raw = await Promise.all(SOURCES.map(source => fetchData<ICmsVideoItem[]>(source)));
	const items: ICmsVideoItem[] = raw.flat();

	/* ---------- dedupe by basename ---------- */
	const seen = new Set<string>();
	const unique = items.filter((it) => {
		const key = path.basename(it.url);

		return !seen.has(key) && Boolean(seen.add(key));  //!seen.has(key), then adding key to Set and return true
	});

	/* ---------- progress bar ---------- */
	const bar = new cliProgress.SingleBar({}, cliProgress.Presets.shades_classic);
	bar.start(unique.length, 0);

	const descriptors: {
		varName: string;
		baseName: string;
		importPath: string;
	}[] = [];

	for (const [idx, it] of unique.entries()) {
		bar.update(idx + 1);

		const isRemote = it.url.startsWith('http');
		const baseName = path.basename(it.url);
		const fileName = isRemote ? `${AUTO_PREFIX}${baseName}` : baseName;
		const localPath = path.join(VIDEOS_DIR, fileName);

		if (!(await fs.stat(localPath).catch(() => false))) {
			/* downloading remote file if not found in localPath */
			if (isRemote) {
				await download(it.url, localPath);
			}
			else {
				throw new Error(`[processImage]: local file is not found at ... ${localPath}`);
			}
		}

		/* download if missing */
/*		if (isRemote && !(await fs.stat(localPath).catch(() => false))) {
			await download(it.url, localPath);
		}*/

		/* build descriptor */
		const varName = `item_${idx}`;
		const importPath = `@v/${fileName}`;
		descriptors.push({ varName, baseName, importPath });
	}

	bar.stop();

	/* ---------- generate TS module ---------- */
	const imports = descriptors.map(d => `import ${d.varName} from "${d.importPath}";`);
	const mapEntries = descriptors.map(d => `  "${d.baseName}": ${d.varName},`);

	const code = [
		'/**',
		' * ‚ö†Ô∏è AUTO-GENERATED FILE ‚Äì DO NOT EDIT MANUALLY',
		' * Generated by:  npm run generate:videos',
		' */',
		'',
		...imports,
		'',
		'export const videoMap = {',
		...mapEntries,
		'} as const;',
		'',
		'export type VideoMapKey = keyof typeof videoMap;',
		'',
	].join('\n');

	await fs.mkdir(path.dirname(OUT_FILE), { recursive: true });
	await fs.writeFile(OUT_FILE, code, 'utf8');

	console.log('‚úÖ  videosMap.ts created / updated');
})().catch(err => {
	console.error('‚ùå  Error:', err);
	process.exitCode = 1;
});